## Git 영역 
![1_zpvd5fjZAFGsVAEsvMGKxA](https://github.com/FE-SW/StudyGit/assets/54196723/dd0e18e0-8285-4166-8737-f3be9ae2ef25)

<b>Working Directory:</b><br/>
작업 디렉토리는 프로젝트의 실제 파일들이 위치하는 곳이다. 이곳에 있는 파일들은 아직 버전 관리에 포함되지 않은 상태이거나, 수정 중인 파일일 수 있다. 여기서 사용자는 파일을 생성, 수정, 삭제 등의 작업을 하며 코드를 편집한다.

<b>Staging Area:</b><br/>
스테이징 영역은 Git에서 커밋을 준비하기 위한 곳이다. "git add" 명령어를 통해 작업 디렉토리에서 변경된 파일들을 스테이징 영역에 추가함으로써, 다음 커밋에 포함될 변경 사항들을 선별적으로 정할 수 있다. 이는 마치 커밋을 위한 임시 저장 공간 같은 역할을 한다.

<b>Repository:</b><br/>
레포지토리는 프로젝트의 모든 파일, 버전 정보, 변경 이력 등을 저장하는 곳이다. 로컬 레포지토리는 개인 컴퓨터에 파일 시스템의 일부로 존재하며, 원격 레포지토리는 GitHub, GitLa 같은 서비스에 호스팅될 수 있다. "git commit" 명령어는 스테이징 영역의 변경 사항을 로컬 레포지토리에 저장한다.


## 커밋참조
Git의 핵심 요소 중 하나는 코드베이스의 변화를 "커밋" 단위로 추적하는 것이다. 커밋은 프로젝트 히스토리의 기본 구성 요소로, 파일에 대한 변경 사항의 집합, 그리고 그 변경에 대한 설명이 포함된 메시지를 담고 있다. 이렇게 각 커밋은 코드 변경의 타임스탬프와 작성자 정보를 가지며, 이전 상태로부터의 구별 가능한 스냅샷을 형성한다. 따라서 Git의 히스토리는 이러한 커밋들의 연속으로 이루어져 있으며, 개발자들은 이를 통해 프로젝트의 변화를 세밀하게 추적하고 관리할 수 있다.

<b>[FETCH_HEAD]:</b>
* FETCH_HEAD는 최근에 실행된 git fetch 명령의 결과를 가리킨다. 이것은 로컬 레포지토리에 있는 특수한 참조로, 원격 레포지토리에서 가져온 브랜치의 최신 커밋을 담고 있다. 이 참조는 원격 변경 사항을 로컬에 병합하기 전에 이를 검토하는 데 주로 사용된다.

<b>[ORIGIN/HEAD]:</b>
* ORIGIN/HEAD는 원격 저장소의 기본 브랜치(대부분의 경우 'main' 또는 'master' 브랜치)를 가리키는 참조이다. 이것은 원격 저장소에 마지막으로 푸시된 커밋을 나타내며, git fetch를 실행하면 로컬의 ORIGIN/HEAD가 업데이트된다.

<b>[HEAD]:</b>
* HEAD는 현재 작업 중인 로컬 브랜치의 최신 커밋을 가리키는 포인터이다. 브랜치를 전환하거나 새로운 커밋을 추가할 때 HEAD는 자동으로 최신 커밋을 가리키도록 이동

<b>[ORIG_HEAD]:</b>
* ORIG_HEAD는 Git에서 중요한 작업을 수행하기 전의 HEAD의 상태를 백업하기 위해 자동으로 생성되는 특별한 참조이다. 예를 들어, 리베이스나 병합과 같이 HEAD를 급격하게 변경할 수 있는 명령을 실행할 때, 현재의 HEAD가 ORIG_HEAD에 저장되므로, 만약 문제가 발생했을 때 사용자가 이전 상태로 쉽게 되돌릴 수 있게 해준다.("현재의 HEAD"라는 표현은 리베이스나 병합과 같은 명령을 실행하기 바로 전의 HEAD를 가리킨다.)
  
<b>[MERGE_HEAD]:</b>
* MERGE_HEAD는 현재 진행 중인 병합 작업에서 병합하려는 커밋(들)을 가리키는 참조이다. git merge 명령을 실행하면, 병합하려는 대상 브랜치의 최근 커밋이 MERGE_HEAD에 기록된다. 이렇게 함으로써, Git은 현재 브랜치(HEAD)와 병합할 커밋(MERGE_HEAD) 사이의 차이를 알고, 적절한 병합 작업을 수행할 수 있다.

간단하게 요약하자면, FETCH_HEAD는 최근에 가져온 변경 사항을, ORIGIN/HEAD는 원격 저장소의 기본 브랜치의 상태를, HEAD는 현재 체크아웃된 로컬 브랜치의 상태를, ORIG_HEAD는 중요한 변경 이전의 HEAD의 상태를, 그리고 MERGE_HEAD는 병합할 커밋들의 정보를 나타낸다.

#### 심볼
HEAD: 현재 체크아웃된 커밋을 나타내는 포인터
```javascript
A---B---C---D (HEAD)
```

~: 특정 조상 커밋을 참조하기 위한 구문
```javascript
A---B---C---D (HEAD~1)---E (HEAD)
```
* HEAD ~ 1: HEAD에서 한 커밋 이전을 참조 -> D커밋
* HEAD ~ 2: C커밋
* HEAD ~ 3: B커밋
* HEAD^1: HEAD의 첫 번째 부모를 참조 -> E 커밋의 첫 번째 부모인 D커밋
* HEAD^2: HEAD의 두 번째 부모를 참조하려고 시도 -> E 커밋은 병합 커밋이 아니므로 두 번째 부모가 없습니다. 따라서 에러를 반환

^: 병합 커밋의 특정 부모를 참조하기 위한 구문
```javascript
  A---B-------E (HEAD)
       \     /
        C---D
```
* HEAD ~ 1: HEAD에서 한 커밋 이전을 참조 이 경우, HEAD~1은 항상 "첫 번째 부모"를 따른다 -> B커밋
* HEAD ~ 2: A커밋
* HEAD ~ 3: A가 루트 커밋이므로, HEAD~3는 존재하지x
* HEAD^1: HEAD의 첫 번째 부모를 참조 ->. 병합 커밋인 E의 경우, 첫 번째 부모는 B커밋
* HEAD^2: D커밋
* HEAD^3: "HEAD의 세 번째 부모를 참조"하는 것을 의미 -> E 커밋은 두 부모만 가지고 있으므로, HEAD^3은 존재하지x


HEAD로부터의 상대적 위치를 나타내는데, ~는 몇 단계의 조상을 나타내는 반면, ^는 병합된 부모들 중 특정 부모를 지정함
